package org.batfish.bddreachability;

import static org.batfish.common.util.CommonUtil.toImmutableMap;

import com.google.common.base.Suppliers;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Sets;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import net.sf.javabdd.BDD;
import org.batfish.common.BatfishException;
import org.batfish.datamodel.Flow;
import org.batfish.symbolic.bdd.BDDOps;
import org.batfish.symbolic.bdd.BDDPacket;
import org.batfish.z3.expr.StateExpr;
import org.batfish.z3.state.NumberedQuery;
import org.batfish.z3.state.OriginateInterfaceLink;
import org.batfish.z3.state.OriginateVrf;
import org.batfish.z3.state.visitors.DefaultTransitionGenerator;

/**
 * A new reachability analysis engine using BDDs. The analysis maintains a graph that describes how
 * packets flow through the network and through logical phases of a router. The graph is similar to
 * the one generated by {@link DefaultTransitionGenerator} for reachability analysis using NOD. In
 * particular, the graph nodes are {@link StateExpr StateExprs} and the edges are mostly the same as
 * the NOD program rules/transitions. {@link BDD BDDs} label the nodes and edges of the graph. A
 * node label represent the set of packets that can reach that node, and an edge label represents
 * the set of packets that can traverse the edge.
 *
 * <p>The two main departures from the NOD program are: 1) ACLs are encoded as a single BDD that
 * labels an edge (rather than a series of states/transitions in NOD programs). 2) Source NAT is
 * handled differently -- we don't maintain separate original and current source IP variables.
 * Instead, we keep track of where/how the packet is transformed as it flows through the network,
 * and reconstruct it after the fact. This requires some work that can't be expressed in BDDs.
 */
public class BDDReachabilityAnalysis {
  /*
   * Stores the essential information about a logical NAT root -- where the NAT occurred, and
   * what the original root was.
   */
  private static class NatRootPosition {
    final StateExpr _natPosition;
    final StateExpr _originalRoot;
    final List<BDDSourceNat> _sourceNats;

    NatRootPosition(StateExpr natPosition, StateExpr originalRoot, List<BDDSourceNat> sourceNats) {
      _natPosition = natPosition;
      _originalRoot = originalRoot;
      _sourceNats = sourceNats;
    }
  }

  public class MultipathConsistencyViolation {
    public final StateExpr originateState;
    public final Set<StateExpr> finalStates;
    public final BDD predicate;

    private MultipathConsistencyViolation(
        StateExpr originateState, Set<StateExpr> finalStates, BDD predicate) {
      this.originateState = originateState;
      this.finalStates = ImmutableSet.copyOf(finalStates);
      this.predicate = predicate;
    }

    public Flow getFlow(String tag) {
      Flow.Builder fb =
          _bddPacket
              .getFlow(this.predicate)
              .orElseGet(
                  () -> {
                    throw new BatfishException(
                        "MultipathConsistencyViolation with UNSAT predicate");
                  });
      fb.setTag(tag);
      if (originateState instanceof OriginateVrf) {
        OriginateVrf originateVrf = (OriginateVrf) originateState;
        fb.setIngressNode(originateVrf.getHostname());
        fb.setIngressVrf(originateVrf.getVrf());
      } else if (originateState instanceof OriginateInterfaceLink) {
        OriginateInterfaceLink originateInterfaceLink = (OriginateInterfaceLink) originateState;
        fb.setIngressNode(originateInterfaceLink.getHostname());
        fb.setIngressInterface(originateInterfaceLink.getIface());
      } else {
        throw new BatfishException(
            "Unexpected originateState type: " + originateState.getClass().getSimpleName());
      }
      return fb.build();
    }
  }

  private final BDDPacket _bddPacket;

  // preState --> postState --> predicate
  private final Map<StateExpr, Map<StateExpr, Edge>> _edges;

  private final Map<StateExpr, BDD> _graphRoots;

  // logical root --> (position,original root)
  private final Map<StateExpr, NatRootPosition> _natRootPositions;

  // natting postState --> root --> logical root
  private final Map<StateExpr, Map<StateExpr, StateExpr>> _natRoots;
  private int _natRootCounter = 0;

  // postState --> source state --> predicate
  private final Supplier<Map<StateExpr, Map<StateExpr, BDD>>> _reachableStates;

  // root state --> leaf state --> predicate
  private final Supplier<Map<StateExpr, Map<StateExpr, BDD>>> _rootToLeafBDDs;

  // for NAT
  private final BDD _srcIpVars;

  private Set<StateExpr> _leafStates;

  BDDReachabilityAnalysis(
      Map<StateExpr, BDD> graphRoots, Map<StateExpr, Map<StateExpr, Edge>> transitions) {
    _bddPacket = new BDDPacket();
    _edges = transitions;
    _graphRoots = ImmutableMap.copyOf(graphRoots);
    _natRootPositions = new HashMap<>();
    _natRoots = new HashMap<>();
    _reachableStates = Suppliers.memoize(this::computeReachableStates);
    _rootToLeafBDDs = Suppliers.memoize(this::computeRootToLeafBDDs);
    _leafStates = computeTerminalStates();
    _srcIpVars = new BDDOps(BDDPacket.factory).and(_bddPacket.getSrcIp().getBitvec());
  }

  /* backward-propagate nat roots to a fixed point */
  private void backwardPropagateNatRoots(Map<StateExpr, Map<StateExpr, BDD>> rootToLeafBDDs) {
    Set<StateExpr> natRootsWorkList = _natRootPositions.keySet();
    Map<StateExpr, Map<StateExpr, BDD>> reachableStates = _reachableStates.get();
    while (!natRootsWorkList.isEmpty()) {
      Set<StateExpr> newWorkList = new HashSet<>();
      for (StateExpr natRoot : natRootsWorkList) {
        NatRootPosition natRootPosition = _natRootPositions.get(natRoot);
        StateExpr originalRoot = natRootPosition._originalRoot;
        List<BDDSourceNat> sourceNats = natRootPosition._sourceNats;
        BDD reachNatBDD = reachableStates.get(natRootPosition._natPosition).get(originalRoot);
        Map<StateExpr, BDD> natRootLeafBDDs = rootToLeafBDDs.get(natRoot);
        natRootLeafBDDs.forEach(
            (leaf, bdd) -> {
              BDD preNatBDD = bdd.getFactory().zero();
              for (BDDSourceNat sourceNat : sourceNats) {
                if (!bdd.and(sourceNat._updateSrcIp).isZero()) {
                  // this could be the NAT rule that was applied
                  preNatBDD =
                      preNatBDD.or(
                          reachNatBDD.and(sourceNat._condition).and(bdd.exist(_srcIpVars)));
                }
              }
              assert !preNatBDD.isZero();
              rootToLeafBDDs
                  .computeIfAbsent(originalRoot, k -> new HashMap<>())
                  .merge(leaf, preNatBDD, BDD::or);
              if (_natRootPositions.containsKey(originalRoot)) {
                // original root is also a nat root; keep back-propagating
                newWorkList.add(originalRoot);
              }
            });
      }
      natRootsWorkList = newWorkList;
    }
  }

  /*
   * node --> root --> set of headers that can reach node from root.
   */
  private Map<StateExpr, Map<StateExpr, BDD>> computeReachableStates() {
    Map<StateExpr, Map<StateExpr, BDD>> reachableStates = new HashMap<>();
    _graphRoots.forEach(
        (root, bdd) -> reachableStates.computeIfAbsent(root, k -> new HashMap<>()).put(root, bdd));

    // each iteration, only process (root, reached node) entries that we need to.
    Map<StateExpr, StateExpr> dirty =
        _graphRoots
            .keySet()
            .stream()
            .collect(ImmutableMap.toImmutableMap(Function.identity(), Function.identity()));

    List<Long> roundTimes = new LinkedList<>();
    List<Integer> roundDirties = new LinkedList<>();

    while (!dirty.isEmpty()) {
      Map<StateExpr, StateExpr> newDirty = new HashMap<>();
      long time = System.currentTimeMillis();

      dirty.forEach(
          (preState, root) -> {
            Map<StateExpr, Edge> preStateOutEdges = _edges.get(preState);
            if (preStateOutEdges == null) {
              // preState has no out-edges
              return;
            }

            BDD preStateBDD = reachableStates.get(preState).get(root);
            preStateOutEdges.forEach(
                (postState, edge) -> {
                  BDD result = preStateBDD.and(edge.getConstraint());
                  if (result.isZero()) {
                    return;
                  }

                  List<BDDSourceNat> sourceNats = edge.getSourceNats();
                  boolean natted = false;
                  if (sourceNats != null) {
                    BDD existSrcIp = result.exist(_srcIpVars);
                    BDD orig = result;
                    result = orig.getFactory().zero();
                    for (BDDSourceNat sourceNat : sourceNats) {
                      BDD match = orig.and(sourceNat._condition);
                      if (!match.isZero()) {
                        natted = true;
                        result = result.or(existSrcIp.and(sourceNat._updateSrcIp));
                        orig = orig.and(sourceNat._condition.not());
                      }
                    }
                    result = result.or(orig);
                  }

                  // we want to remember the source BDD, but NAT is destructive. So we're going
                  // to map back to it. We'll create a new dummy state for each combination of
                  // postState/root.
                  StateExpr logicalRoot;
                  if (natted) {
                    logicalRoot =
                        _natRoots
                            .computeIfAbsent(postState, k -> new HashMap<>())
                            .computeIfAbsent(root, k -> new NumberedQuery(this._natRootCounter++));
                    _natRootPositions.computeIfAbsent(
                        logicalRoot, k -> new NatRootPosition(preState, root, sourceNats));
                  } else {
                    logicalRoot = root;
                  }

                  // update postState BDD reachable from source
                  Map<StateExpr, BDD> reachPostState =
                      reachableStates.computeIfAbsent(postState, k -> new HashMap<>());
                  BDD oldReach = reachPostState.get(logicalRoot);
                  BDD newReach = oldReach == null ? result : oldReach.or(result);

                  if (oldReach == null || !oldReach.equals(newReach)) {
                    reachPostState.put(logicalRoot, newReach);
                    newDirty.put(postState, logicalRoot);
                  }
                });
          });

      dirty = newDirty;

      time = System.currentTimeMillis() - time;
      roundTimes.add(time);
      roundDirties.add(dirty.size());
    }

    return toImmutableMap(
        reachableStates,
        Entry::getKey,
        rootEntry -> toImmutableMap(rootEntry.getValue(), Entry::getKey, Entry::getValue));
  }

  private Map<StateExpr, Map<StateExpr, BDD>> computeRootToLeafBDDs() {
    // root --> terminal state --> BDD
    Map<StateExpr, Map<StateExpr, BDD>> rootToLeafBDDs = new HashMap<>();
    _reachableStates
        .get()
        .entrySet()
        .stream()
        .filter(entry -> _leafStates.contains(entry.getKey()))
        .forEach(
            entry -> {
              StateExpr leafState = entry.getKey();
              entry
                  .getValue()
                  .forEach(
                      (root, bdd) -> {
                        rootToLeafBDDs
                            .computeIfAbsent(root, k -> new HashMap<>())
                            .put(leafState, bdd);
                      });
            });

    backwardPropagateNatRoots(rootToLeafBDDs);

    return toImmutableMap(
        rootToLeafBDDs,
        Entry::getKey,
        rootEntry -> toImmutableMap(rootEntry.getValue(), Entry::getKey, Entry::getValue));
  }

  private Set<StateExpr> computeTerminalStates() {
    Set<StateExpr> preStates = _edges.keySet();
    Set<StateExpr> postStates =
        _edges.values().stream().flatMap(m -> m.keySet().stream()).collect(Collectors.toSet());
    return ImmutableSet.copyOf(Sets.difference(postStates, preStates));
  }

  /**
   * Return a list of {@link MultipathConsistencyViolation multipath consistency violations}
   * detected in the network.
   */
  public List<MultipathConsistencyViolation> detectMultipathInconsistency() {
    final class Candidate {
      private StateExpr _root;
      private StateExpr _leaf1;
      private StateExpr _leaf2;
      private BDD _leaf1BDD;
      private BDD _leaf2BDD;

      private Candidate(
          StateExpr root, StateExpr leaf1, StateExpr leaf2, BDD leaf1BDD, BDD leaf2BDD) {
        _root = root;
        _leaf1 = leaf1;
        _leaf2 = leaf2;
        _leaf1BDD = leaf1BDD;
        _leaf2BDD = leaf2BDD;
      }
    }

    // generate candidates in parallel, since we can
    List<Candidate> candidates =
        _rootToLeafBDDs
            .get()
            .entrySet()
            .parallelStream()
            .flatMap(
                entry -> {
                  StateExpr root = entry.getKey();
                  Map<StateExpr, BDD> leafBDDs = entry.getValue();
                  return _leafStates
                      .stream()
                      .filter(leafBDDs::containsKey)
                      .flatMap(
                          leaf1 -> {
                            BDD leaf1BDD = leafBDDs.get(leaf1);
                            return _leafStates
                                .stream()
                                .filter(leaf2 -> leaf1 != leaf2)
                                .filter(leafBDDs::containsKey)
                                // avoid duplicate violations
                                .filter(leaf2 -> leaf1.toString().compareTo(leaf2.toString()) < 1)
                                .map(
                                    leaf2 -> {
                                      BDD leaf2BDD = leafBDDs.get(leaf2);
                                      return new Candidate(root, leaf1, leaf2, leaf1BDD, leaf2BDD);
                                    });
                          });
                })
            .collect(Collectors.toList());

    return candidates
        .stream()
        .flatMap(
            candidate -> {
              BDD intersection = candidate._leaf1BDD.and(candidate._leaf2BDD);
              return intersection.isZero()
                  ? Stream.empty()
                  : Stream.of(
                      new MultipathConsistencyViolation(
                          candidate._root,
                          ImmutableSet.of(candidate._leaf1, candidate._leaf2),
                          intersection));
            })
        .collect(ImmutableList.toImmutableList());
  }

  Set<StateExpr> getLeafStates() {
    return _leafStates;
  }

  Map<StateExpr, Map<StateExpr, StateExpr>> getNatRoots() {
    _reachableStates.get(); // force the computation
    return _natRoots;
  }

  Map<StateExpr, Map<StateExpr, BDD>> getReachableStates() {
    return _reachableStates.get();
  }

  Map<StateExpr, Map<StateExpr, BDD>> getRootToLeafBDDs() {
    return _rootToLeafBDDs.get();
  }
}
